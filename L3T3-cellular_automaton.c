//Клеточные автоматы - невероятно крутая в своей простоте штука.

    //Создайте массив A длины N (N - нечетное). Заполните его нулями везде кроме середины (N / 2 + 1). В середине поставьте единицу
    //Выведите массив A
    //Создайте массив B длины N. Заполните его нулями.
    //Создайте указатели a (&A) и b (&B)
    //Заполните массив на который указывает b по следующему правилу:
    //a. Для вычисления bi используются значения триады из массива на который указывает a.

    //a[i-1] a[i] a[i+1]
    //   |     |     |
    //   └-----|-----┘
    //       rule
    //         |
    //...    b[i]    ...

    //b. На вход rule попадает 3 бита. Например (101, 000, 111, 001 и т.д.)
    //c. Эти 3 бита преобразуются в число от 0 до 7 (101 - 5, 000 - 0, и т.д.). Назовем это число x
    //d. rule это на самом деле какая-то константа от 0 до 255 (для начала возьмите rule = 30)
    //e. Возьмите бит под номером x из числа rule. (Сделать это можно в две операции - битовый сдвиг и конъюнкция)
    //f. Получившийся бит и будет новым значением в b[i]
    //Выведите массив B
    //Поменяйте указатели местами. (Так что a станет указывать на B, а b на A или наоборот)
    //Перейдите на шаг 5

//Как вы могли догадаться, получается цикл.
//Выполните его какое-нибудь фиксированное число раз, или используйте while (1) и usleep(100 * 1000) (нужно будет подключить #include<time.h>)
//Попробуйте позапускать программу с разными значениями
//rule - например [30, 110, 45, 60, 62, 72, 73, 74, 75, 82, 86, 88, 89, 90, 94, 101, 102,
//104, 105, 106, 108, 109, 118, 120, 126, 134, 138, 144, 146, 148, 150, 166, 180, 182, 210]
//Попробуйте модифицировать вывод, чтобы выводились не 1 / 0 а какие-нибудь значки. Например пробел и #

#include <stdio.h>
#include <unistd.h>

// Количество клеток
const int count=61;

int Index (int x)
{
if (x<0) return x+count; else return x%count;
}
// Функция поведения клетки
int f(int a1,int a2, int a3)
   {
return a1 ^ a2 ^ a3;
   }
// Главная функция
int main(int argc, char* argv[])
       {
int A[count];
int B[count];

// <enter> и <e> (exit)
char c;

for (int i=0; i<count; i++)
           {
A[i]=0;
           }
A[30]=1;
// Итерации автомата
for (;;)
               {
for (int i=0; i<count; i++)

printf("%c",A[i] ? '*' : ' ');

for (int i=0; i<count; i++)
                     {
B[i]=f(A[Index(i-1)],A[Index(i)],A[Index(i+1)]);
                     }
for (int i=0; i<count; i++)
A[i]=B[i];

c=getchar();

if (c=='e') return 0;

               }
return 0;
       }
